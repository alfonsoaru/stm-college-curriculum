<!DOCTYPE html>
<html lang="en" translate="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="google" content="notranslate">
    <title>Map Explorer - Geography Year 7 Autumn Term</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            min-height: 100vh;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }

        #game-canvas {
            display: block;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            z-index: 100;
        }

        .hud-item {
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: 600;
            font-size: 1.1rem;
        }

        #question-overlay {
            display: block;
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 550px;
            z-index: 150;
            pointer-events: none;
        }

        .question-box {
            background: rgba(255,255,255,0.95);
            border-radius: 16px;
            padding: 1.2rem;
            text-align: center;
            animation: slideDown 0.3s ease;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            border: 3px solid #10b981;
            pointer-events: auto;
        }

        @keyframes slideDown {
            from { transform: translateY(-100px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .checkpoint-badge {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 600;
            display: inline-block;
            margin-bottom: 0.5rem;
        }

        .question-text {
            font-size: 1.3rem;
            font-weight: 700;
            color: #1d1d1f;
            margin-bottom: 0.2rem;
        }

        .question-context {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 0.8rem;
        }

        .answers-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .answer-btn {
            background: #f5f5f7;
            border: 2px solid #e5e5e5;
            padding: 0.6rem 0.8rem;
            border-radius: 10px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .answer-btn:hover {
            background: #e8e8ed;
            border-color: #10b981;
            transform: translateY(-2px);
        }

        .answer-btn.correct {
            background: #22c55e;
            border-color: #16a34a;
            color: white;
        }

        .answer-btn.wrong {
            background: #ef4444;
            border-color: #dc2626;
            color: white;
        }

        #start-screen, #gameover-screen, #win-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            z-index: 300;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            padding: 2rem;
        }

        #gameover-screen, #win-screen {
            display: none;
        }

        .title {
            font-size: 3.5rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            text-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.3rem;
            opacity: 0.9;
            margin-bottom: 2rem;
        }

        .instructions {
            background: rgba(255,255,255,0.1);
            padding: 2rem;
            border-radius: 15px;
            margin-bottom: 2rem;
            max-width: 600px;
            text-align: left;
        }

        .instructions em {
            opacity: 0.8;
            font-size: 0.9em;
        }

        .instructions h3 {
            margin-bottom: 1rem;
            font-size: 1.3rem;
        }

        .instructions p {
            margin: 0.5rem 0;
            font-size: 1rem;
        }

        .start-btn {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            border: none;
            padding: 1.2rem 3rem;
            font-size: 1.4rem;
            font-weight: 700;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.4);
        }

        .start-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 30px rgba(59, 130, 246, 0.5);
        }

        .theme-emoji {
            font-size: 5rem;
            margin-bottom: 1rem;
        }

        .result-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
        }

        .stats {
            background: rgba(255,255,255,0.1);
            padding: 1.5rem 2rem;
            border-radius: 12px;
            margin: 1.5rem 0;
        }

        .feedback-text {
            font-size: 0.9rem;
            margin-top: 0.5rem;
            padding: 0.5rem;
            border-radius: 6px;
            display: none;
            font-weight: 600;
        }

        .feedback-text.correct {
            background: rgba(34, 197, 94, 0.2);
            color: #166534;
            display: block;
        }

        .feedback-text.wrong {
            background: rgba(239, 68, 68, 0.2);
            color: #991b1b;
            display: block;
            font-size: 0.8rem;
        }

        #mobile-controls {
            display: none;
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }

        .jump-btn {
            background: rgba(255,255,255,0.9);
            border: none;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            font-size: 2.5rem;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        @media (max-width: 768px) {
            #mobile-controls {
                display: block;
            }
            .title {
                font-size: 2.5rem;
            }
            .question-text {
                font-size: 1.1rem;
            }
            .answers-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>

        <div id="hud">
            <div class="hud-item">Level: <span id="level">1</span>/3</div>
            <div class="hud-item">&#x1F9ED; <span id="compasses">0</span></div>
            <div class="hud-item">&#x2B50; <span id="score">0</span></div>
            <div class="hud-item">&#x2764;&#xFE0F; <span id="lives">3</span></div>
        </div>

        <div id="mobile-controls">
            <button class="jump-btn" id="jump-btn">&#x2B06;&#xFE0F;</button>
        </div>

        <div id="question-overlay">
            <div class="question-box">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                    <div class="checkpoint-badge">&#x1F5FA;&#xFE0F; Q<span id="checkpoint-num">1</span>/<span id="total-questions">12</span></div>
                    <button id="read-again-btn" onclick="rereadQuestion()" style="background: #10b981; color: white; border: none; padding: 5px 12px; border-radius: 15px; font-size: 0.8rem; cursor: pointer; font-weight: 600;">&#x1F50A; Read Again</button>
                </div>
                <div class="question-text" id="q-text">Loading...</div>
                <div class="question-context" id="q-context">Map Skills Practice</div>
                <div class="answers-grid" id="answers"></div>
                <div class="feedback-text" id="feedback"></div>
            </div>
        </div>

        <div id="start-screen">
            <div class="theme-emoji">&#x1F5FA;&#xFE0F;</div>
            <h1 class="title">Map Explorer</h1>
            <p class="subtitle">Run, Jump & Master Geography!<br><em style="font-size: 0.9em; opacity: 0.8;">Year 7 Autumn Term - Map Skills & UK Geography</em></p>

            <div class="instructions">
                <h3>How to Play</h3>
                <p>&#x1F3C3; <strong>RUN</strong> across mountains and valleys!</p>
                <p>&#x1F5FA;&#xFE0F; Answer <strong>MAP SKILLS & UK GEOGRAPHY</strong> questions!</p>
                <p>&#x1F9ED; Collect compasses and maps for bonus points!</p>

                <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.2);">
                    <p><strong>&#x2328;&#xFE0F; Keyboard:</strong> SPACE = Jump | A B C D = Answer</p>
                    <p><strong>&#x1F3AE; Xbox:</strong> RT/LT = Jump | X Y A B = Answer</p>
                </div>

                <p style="margin-top: 1rem;">&#x2705; Correct = +1 Life | Master grid references & world locations!</p>
            </div>

            <button class="start-btn" onclick="startGame()">Start Exploring! &#x1F30D;</button>
        </div>

        <div id="gameover-screen">
            <div class="result-icon">&#x1F494;</div>
            <h1 class="title">Game Over!</h1>
            <p class="subtitle">You lost all your lives!</p>
            <div class="stats">
                <p>Level: <span id="final-level">1</span></p>
                <p>Score: <span id="final-score">0</span></p>
            </div>
            <button class="start-btn" onclick="startGame()">Try Again! &#x1F504;</button>
        </div>

        <div id="win-screen">
            <div class="result-icon">&#x1F3C6;</div>
            <h1 class="title">Congratulations!</h1>
            <p class="subtitle">You're a Geography Master!</p>
            <div class="stats">
                <p>&#x1F9ED; Compasses: <span id="win-compasses">0</span></p>
                <p>&#x2B50; Score: <span id="win-score">0</span></p>
            </div>
            <button class="start-btn" onclick="startGame()">Play Again! &#x1F504;</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameRunning = false;
        let level = 1;
        let score = 0;
        let lives = 3;
        let distance = 0;
        let checkpointDistance = 22000;
        let gameSpeed = 4;
        let baseSpeed = 4;
        let isSpeakingFeedback = false;

        // Collectibles
        let compasses = [];
        let compassCount = 0;

        // Power-ups
        let powerUps = [];
        let isInvincible = false;
        let invincibleTimer = 0;

        // Player
        let player = {
            x: 100,
            y: 0,
            width: 50,
            height: 70,
            velocityY: 0,
            jumping: false,
            grounded: true
        };

        // Physics
        const gravity = 0.8;
        const jumpForce = -16;

        // Obstacles
        let obstacles = [];
        let obstacleTimer = 0;

        // Background
        let bgOffset = 0;
        let mountains = [];
        let clouds = [];

        // Geography Questions - Year 7 Autumn Term (12 Questions)
        const questions = [
            // Map Skills - Grid References
            {
                text: "What type of grid reference pinpoints a 1km square?",
                context: "Map Skills - Grid References",
                answers: ["Four-figure", "Six-figure", "Two-figure", "Eight-figure"],
                correct: 0,
                english: "A four-figure grid reference (like 3245) identifies a 1km x 1km square on an Ordnance Survey map. The first two digits show the eastings (left to right), and the last two show the northings (bottom to top)."
            },
            {
                text: "In a six-figure grid reference, how accurate is the location?",
                context: "Map Skills - Grid References",
                answers: ["100 metres", "1 kilometre", "10 metres", "1 metre"],
                correct: 0,
                english: "A six-figure grid reference (like 324456) pinpoints a location to within 100 metres. This is much more precise than a four-figure reference, making it useful for navigation and emergency services."
            },
            {
                text: "When reading a grid reference, which direction do you read first?",
                context: "Map Skills - Grid References",
                answers: ["Along (east)", "Up (north)", "Down (south)", "Left (west)"],
                correct: 0,
                english: "Remember 'Along the corridor, then up the stairs' - you always read eastings (along the bottom) first, then northings (up the side). This gives you the correct grid reference."
            },
            // Map Skills - Contours and Scale
            {
                text: "What do contour lines that are close together indicate?",
                context: "Map Skills - Relief & Contours",
                answers: ["Steep slope", "Gentle slope", "Flat land", "Valley"],
                correct: 0,
                english: "When contour lines are close together, the land rises or falls quickly - this means a steep slope. Far apart contour lines indicate gentle slopes or relatively flat terrain."
            },
            {
                text: "What is a spot height on an OS map?",
                context: "Map Skills - Relief & Contours",
                answers: ["Exact height at a point", "Type of building", "River crossing", "Forest area"],
                correct: 0,
                english: "A spot height is a black dot with a number showing the exact height above sea level at that precise point. They're especially useful on hilltops and other key locations."
            },
            {
                text: "What does the scale 1:25,000 mean on an OS map?",
                context: "Map Skills - Scale",
                answers: ["1cm = 250m", "1cm = 25m", "1cm = 2.5km", "1cm = 25km"],
                correct: 0,
                english: "On a 1:25,000 scale map, 1 centimetre on the map represents 25,000 centimetres (250 metres) in real life. This scale is commonly used for walkers and shows great detail."
            },
            // UK Geography
            {
                text: "What is the capital city of Scotland?",
                context: "UK Geography - Countries & Capitals",
                answers: ["Edinburgh", "Glasgow", "Aberdeen", "Dundee"],
                correct: 0,
                english: "Edinburgh is the capital of Scotland, located on the east coast. Glasgow is the largest city by population, but Edinburgh is where the Scottish Parliament sits and is the official capital."
            },
            {
                text: "Which mountain is the highest peak in the UK?",
                context: "UK Geography - Physical Features",
                answers: ["Ben Nevis", "Snowdon", "Scafell Pike", "Helvellyn"],
                correct: 0,
                english: "Ben Nevis in the Scottish Highlands stands at 1,345 metres, making it the highest peak in the UK. Snowdon (1,085m) is highest in Wales, and Scafell Pike (978m) is highest in England."
            },
            {
                text: "Which river is the longest in the UK?",
                context: "UK Geography - Physical Features",
                answers: ["River Severn", "River Thames", "River Trent", "River Mersey"],
                correct: 0,
                english: "The River Severn is 354 km long, making it the longest river in the UK. It flows from Wales through the West Midlands to the Bristol Channel. The Thames (346 km) is second longest."
            },
            // World Geography - Continents & Oceans
            {
                text: "How many continents are there in the world?",
                context: "World Geography - Continents",
                answers: ["7", "5", "6", "8"],
                correct: 0,
                english: "There are 7 continents: Africa, Antarctica, Asia, Australia/Oceania, Europe, North America, and South America. Asia is the largest by both area and population."
            },
            {
                text: "Which continent is the largest by land area?",
                context: "World Geography - Continents",
                answers: ["Asia", "Africa", "North America", "Europe"],
                correct: 0,
                english: "Asia is the largest continent, covering about 44.6 million square kilometres - that's about 30% of Earth's total land area. It stretches from the Middle East to Japan and from Siberia to Indonesia."
            },
            {
                text: "Which ocean is the largest in the world?",
                context: "World Geography - Oceans",
                answers: ["Pacific Ocean", "Atlantic Ocean", "Indian Ocean", "Arctic Ocean"],
                correct: 0,
                english: "The Pacific Ocean is the largest and deepest ocean, covering about 165 million square kilometres - more than all the land on Earth combined! It stretches from Asia and Australia to the Americas."
            }
        ];

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            player.y = canvas.height - 150 - player.height;
            ctx.imageSmoothingEnabled = false;
        }

        function generateMountains() {
            mountains = [];
            for (let i = 0; i < 10; i++) {
                mountains.push({
                    x: i * 200 + Math.random() * 100,
                    height: 100 + Math.random() * 150,
                    width: 150 + Math.random() * 100
                });
            }
        }

        function generateClouds() {
            clouds = [];
            for (let i = 0; i < 6; i++) {
                clouds.push({
                    x: i * 300 + Math.random() * 150,
                    y: 40 + Math.random() * 60,
                    size: 25 + Math.random() * 20
                });
            }
        }

        function drawBackground() {
            // Sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.6);
            skyGradient.addColorStop(0, '#60a5fa');
            skyGradient.addColorStop(1, '#93c5fd');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height * 0.6);

            // Sun
            ctx.fillStyle = '#fbbf24';
            ctx.beginPath();
            ctx.arc(canvas.width - 120, 80, 50, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fcd34d';
            ctx.beginPath();
            ctx.arc(canvas.width - 120, 80, 40, 0, Math.PI * 2);
            ctx.fill();

            // Clouds
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            clouds.forEach(cloud => {
                const cloudX = ((cloud.x - bgOffset * 0.2) % (canvas.width + 300)) - 100;
                drawCloud(cloudX, cloud.y, cloud.size);
            });

            // Distant mountains (background layer)
            mountains.forEach((mountain, idx) => {
                const mtX = ((mountain.x - bgOffset * 0.3) % (canvas.width + 400)) - 200;
                drawMountain(mtX, canvas.height * 0.65 - mountain.height * 0.6, mountain.height * 0.6, mountain.width * 0.8, '#9ca3af');
            });

            // Closer mountains (mid layer)
            mountains.forEach((mountain, idx) => {
                const mtX = ((mountain.x + 100 - bgOffset * 0.5) % (canvas.width + 400)) - 200;
                drawMountain(mtX, canvas.height * 0.65 - mountain.height * 0.8, mountain.height * 0.8, mountain.width * 0.9, '#6b7280');
            });

            // Foreground mountains
            mountains.forEach((mountain, idx) => {
                const mtX = ((mountain.x + 50 - bgOffset * 0.7) % (canvas.width + 400)) - 200;
                drawMountain(mtX, canvas.height * 0.65 - mountain.height, mountain.height, mountain.width, '#4b5563');
            });

            // Grass field
            ctx.fillStyle = '#22c55e';
            ctx.fillRect(0, canvas.height - 150, canvas.width, 150);

            // Grass details
            ctx.fillStyle = '#16a34a';
            for (let x = -bgOffset % 30; x < canvas.width; x += 30) {
                ctx.beginPath();
                ctx.moveTo(x, canvas.height - 150);
                ctx.lineTo(x + 5, canvas.height - 165);
                ctx.lineTo(x + 10, canvas.height - 150);
                ctx.fill();
            }

            // Draw grid lines on ground (like a map)
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            for (let x = -bgOffset % 100; x < canvas.width; x += 100) {
                ctx.beginPath();
                ctx.moveTo(x, canvas.height - 150);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
        }

        function drawCloud(x, y, size) {
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.arc(x + size, y - 5, size * 1.2, 0, Math.PI * 2);
            ctx.arc(x + size * 2, y, size, 0, Math.PI * 2);
            ctx.arc(x + size, y + 8, size * 0.8, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawMountain(x, y, height, width, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x, y + height);
            ctx.lineTo(x + width / 2, y);
            ctx.lineTo(x + width, y + height);
            ctx.closePath();
            ctx.fill();

            // Snow cap
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(x + width / 2, y);
            ctx.lineTo(x + width / 2 - width * 0.1, y + height * 0.2);
            ctx.lineTo(x + width / 2 + width * 0.1, y + height * 0.2);
            ctx.closePath();
            ctx.fill();
        }

        function drawPlayer() {
            // Body - explorer outfit
            ctx.fillStyle = '#059669';
            ctx.fillRect(player.x, player.y + 20, player.width - 10, 35);

            // Head
            ctx.fillStyle = '#fcd5b8';
            ctx.beginPath();
            ctx.arc(player.x + 20, player.y + 12, 15, 0, Math.PI * 2);
            ctx.fill();

            // Explorer hat
            ctx.fillStyle = '#92400e';
            ctx.beginPath();
            ctx.ellipse(player.x + 20, player.y + 5, 20, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(player.x + 20, player.y + 2, 12, Math.PI, 0);
            ctx.fill();

            // Backpack
            ctx.fillStyle = '#dc2626';
            ctx.fillRect(player.x + 30, player.y + 22, 12, 25);

            // Legs
            ctx.fillStyle = '#1d4ed8';
            if (player.grounded) {
                ctx.fillRect(player.x + 5, player.y + 55, 12, 15);
                ctx.fillRect(player.x + 22, player.y + 55, 12, 15);
            } else {
                ctx.fillRect(player.x + 5, player.y + 50, 12, 20);
                ctx.fillRect(player.x + 22, player.y + 50, 12, 20);
            }

            // Invincibility effect
            if (isInvincible) {
                ctx.strokeStyle = 'rgba(251, 191, 36, 0.8)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(player.x + 25, player.y + 35, 45, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function spawnObstacle() {
            const types = [
                { width: 50, height: 50, emoji: '\u{1FAA8}' }, // Rock
                { width: 45, height: 55, emoji: '\u{1F332}' }, // Tree
                { width: 55, height: 40, emoji: '\u{26FA}' }, // Tent
                { width: 40, height: 45, emoji: '\u{1F9ED}' }, // Compass obstacle
                { width: 45, height: 50, emoji: '\u{1F6B6}' }, // Hiker
                { width: 50, height: 45, emoji: '\u{1F392}' }  // Backpack
            ];
            const type = types[Math.floor(Math.random() * types.length)];

            obstacles.push({
                x: canvas.width + 50,
                y: canvas.height - 150 - type.height,
                width: type.width,
                height: type.height,
                emoji: type.emoji
            });

            if (Math.random() < 0.15 && level > 1) {
                const type2 = types[Math.floor(Math.random() * types.length)];
                obstacles.push({
                    x: canvas.width + 150,
                    y: canvas.height - 150 - type2.height,
                    width: type2.width,
                    height: type2.height,
                    emoji: type2.emoji
                });
            }
        }

        function spawnCompass() {
            const heights = [80, 120, 160];
            const collectibles = ['\u{1F9ED}', '\u{1F5FA}\uFE0F', '\u{1F4CD}'];
            compasses.push({
                x: canvas.width + 50,
                y: canvas.height - 150 - heights[Math.floor(Math.random() * heights.length)],
                emoji: collectibles[Math.floor(Math.random() * collectibles.length)],
                collected: false
            });
        }

        function spawnPowerUp() {
            const types = ['globe', 'map', 'star'];
            powerUps.push({
                x: canvas.width + 50,
                y: canvas.height - 280,
                type: types[Math.floor(Math.random() * types.length)],
                collected: false
            });
        }

        function drawObstacles() {
            obstacles.forEach(obs => {
                ctx.font = `${obs.height}px Arial`;
                ctx.fillText(obs.emoji, obs.x, obs.y + obs.height - 5);
            });
        }

        function drawCompasses() {
            compasses.forEach(c => {
                if (!c.collected) {
                    ctx.font = '35px Arial';
                    const bob = Math.sin(Date.now() / 200 + c.x) * 5;
                    ctx.fillText(c.emoji, c.x, c.y + bob);
                }
            });
        }

        function drawPowerUps() {
            powerUps.forEach(p => {
                if (!p.collected) {
                    ctx.font = '40px Arial';
                    const bob = Math.sin(Date.now() / 150) * 8;
                    let emoji = p.type === 'globe' ? '\u{1F30D}' : p.type === 'map' ? '\u{1F5FA}\uFE0F' : '\u{2B50}';
                    ctx.fillText(emoji, p.x, p.y + bob);
                }
            });
        }

        function drawProgressBar() {
            const barWidth = 200;
            const barHeight = 10;
            const barX = canvas.width / 2 - barWidth / 2;
            const barY = 70;
            const progress = Math.min(distance / checkpointDistance, 1);

            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            ctx.fillStyle = '#22c55e';
            ctx.fillRect(barX, barY, barWidth * progress, barHeight);

            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.fillText('\u{1F3C1}', barX + barWidth - 15, barY + 10);
        }

        let compassSpawnTimer = 0;
        let powerUpSpawnTimer = 0;
        let comboCount = 0;
        let comboTimer = 0;

        function update() {
            if (!gameRunning) return;

            gameSpeed = Math.min(baseSpeed + 5, baseSpeed + (distance / 5000));

            bgOffset += gameSpeed;
            distance += gameSpeed;

            if (!player.grounded) {
                player.velocityY += gravity;
                player.y += player.velocityY;

                if (player.y >= canvas.height - 150 - player.height) {
                    player.y = canvas.height - 150 - player.height;
                    player.velocityY = 0;
                    player.grounded = true;
                    player.jumping = false;
                }
            }

            obstacleTimer++;
            const obstacleFreq = Math.max(80, 180 - gameSpeed * 15);
            if (obstacleTimer > obstacleFreq + Math.random() * 60) {
                spawnObstacle();
                obstacleTimer = 0;
            }

            compassSpawnTimer++;
            if (compassSpawnTimer > 40 + Math.random() * 30) {
                spawnCompass();
                compassSpawnTimer = 0;
            }

            powerUpSpawnTimer++;
            if (powerUpSpawnTimer > 400 + Math.random() * 200) {
                spawnPowerUp();
                powerUpSpawnTimer = 0;
            }

            obstacles.forEach(obs => { obs.x -= gameSpeed; });
            compasses.forEach(c => { c.x -= gameSpeed; });
            powerUps.forEach(p => { p.x -= gameSpeed; });

            obstacles = obstacles.filter(obs => obs.x > -100);
            compasses = compasses.filter(c => c.x > -100);
            powerUps = powerUps.filter(p => p.x > -100);

            if (!isInvincible) {
                obstacles.forEach(obs => {
                    if (player.x < obs.x + obs.width - 10 &&
                        player.x + player.width - 10 > obs.x &&
                        player.y + player.height > obs.y &&
                        player.y < obs.y + obs.height) {
                        hitObstacle();
                    }
                });
            }

            compasses.forEach(c => {
                if (!c.collected &&
                    player.x < c.x + 35 &&
                    player.x + player.width > c.x &&
                    player.y < c.y + 35 &&
                    player.y + player.height > c.y - 20) {
                    c.collected = true;
                    compassCount++;
                    score += 50;
                    comboCount++;
                    comboTimer = 60;
                    if (comboCount >= 3) score += comboCount * 20;
                }
            });

            powerUps.forEach(p => {
                if (!p.collected &&
                    player.x < p.x + 40 &&
                    player.x + player.width > p.x &&
                    player.y < p.y + 20 &&
                    player.y + player.height > p.y - 30) {
                    p.collected = true;
                    activatePowerUp(p.type);
                }
            });

            if (comboTimer > 0) comboTimer--;
            else comboCount = 0;

            if (isInvincible) {
                invincibleTimer--;
                if (invincibleTimer <= 0) isInvincible = false;
            }

            if (distance >= checkpointDistance) reachCheckpoint();

            document.getElementById('score').textContent = score;
            document.getElementById('compasses').textContent = compassCount;
        }

        function activatePowerUp(type) {
            if (type === 'star') {
                isInvincible = true;
                invincibleTimer = 180;
            } else if (type === 'map') {
                gameSpeed = Math.max(3, gameSpeed - 2);
                setTimeout(() => { gameSpeed = baseSpeed; }, 3000);
            } else if (type === 'globe') {
                compasses.forEach(c => {
                    if (!c.collected && c.x < player.x + 300) {
                        c.x = player.x + 30;
                        c.y = player.y + 20;
                    }
                });
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            drawCompasses();
            drawPowerUps();
            drawObstacles();
            drawPlayer();
            drawProgressBar();

            if (comboCount >= 3) {
                ctx.fillStyle = '#fbbf24';
                ctx.font = 'bold 24px Arial';
                ctx.fillText(`COMBO x${comboCount}!`, player.x - 20, player.y - 30);
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function jump() {
            if (player.grounded && gameRunning) {
                player.velocityY = jumpForce;
                player.grounded = false;
                player.jumping = true;
            }
        }

        function hitObstacle() {
            lives--;
            document.getElementById('lives').textContent = lives;

            if (lives <= 0) {
                gameOver();
            } else {
                obstacles = [];
                distance = Math.max(0, distance - 200);
                canvas.style.filter = 'brightness(2)';
                setTimeout(() => canvas.style.filter = 'none', 100);
            }
        }

        function reachCheckpoint() {
            distance = 0;
            level++;

            if (level > 3) {
                winGame();
                return;
            }

            checkpointDistance = 22000 + level * 2000;
            baseSpeed = 4 + level * 0.5;
            gameSpeed = baseSpeed;
            document.getElementById('level').textContent = level;
        }

        // TTS Functions
        function speak(text, lang = 'en-GB') {
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = lang;
                utterance.rate = 0.9;
                const voices = speechSynthesis.getVoices();
                const voice = voices.find(v => v.lang.startsWith(lang.split('-')[0]));
                if (voice) utterance.voice = voice;
                speechSynthesis.speak(utterance);
            }
        }

        function showQuestion() {
            const question = questions[questionCount % questions.length];
            currentQuestion = question;

            const questionInCycle = (questionCount % questions.length) + 1;
            document.getElementById('checkpoint-num').textContent = questionInCycle;
            document.getElementById('total-questions').textContent = questions.length;
            document.getElementById('q-text').textContent = question.text;
            document.getElementById('q-context').textContent = question.context;

            const answersDiv = document.getElementById('answers');
            answersDiv.innerHTML = '';

            const shuffledAnswers = question.answers.map((ans, i) => ({ text: ans, isCorrect: i === question.correct }));
            shuffledAnswers.sort(() => Math.random() - 0.5);
            currentAnswers = shuffledAnswers;

            const labels = ['A', 'B', 'C', 'D'];
            shuffledAnswers.forEach((ans, i) => {
                const btn = document.createElement('button');
                btn.className = 'answer-btn';
                btn.onclick = () => handleAnswer(btn, ans.isCorrect, question.english);
                btn.innerHTML = `<strong>${labels[i]}</strong> ${ans.text}`;
                answersDiv.appendChild(btn);
            });

            document.getElementById('feedback').textContent = '';
            document.getElementById('feedback').className = 'feedback-text';

            readQuestionAndAnswers(question.text, shuffledAnswers, labels);
        }

        function readQuestionAndAnswers(questionText, answers, labels) {
            if (!('speechSynthesis' in window)) return;
            if (isSpeakingFeedback) return;

            speechSynthesis.cancel();

            const voices = speechSynthesis.getVoices();
            const englishVoice = voices.find(v => v.lang === 'en-GB' && v.name.includes('Google')) ||
                                voices.find(v => v.lang.startsWith('en'));

            const queue = [];

            // Question
            const qUtterance = new SpeechSynthesisUtterance(questionText);
            qUtterance.lang = 'en-GB';
            qUtterance.rate = 0.9;
            if (englishVoice) qUtterance.voice = englishVoice;
            queue.push(qUtterance);

            // Answers
            answers.forEach((ans, i) => {
                const labelUtterance = new SpeechSynthesisUtterance(labels[i]);
                labelUtterance.lang = 'en-GB';
                labelUtterance.rate = 1.0;
                if (englishVoice) labelUtterance.voice = englishVoice;
                queue.push(labelUtterance);

                const ansUtterance = new SpeechSynthesisUtterance(ans.text);
                ansUtterance.lang = 'en-GB';
                ansUtterance.rate = 0.85;
                if (englishVoice) ansUtterance.voice = englishVoice;
                queue.push(ansUtterance);
            });

            let i = 0;
            function playNext() {
                if (i < queue.length) {
                    queue[i].onend = playNext;
                    speechSynthesis.speak(queue[i]);
                    i++;
                }
            }
            playNext();
        }

        if ('speechSynthesis' in window) {
            speechSynthesis.getVoices();
            speechSynthesis.onvoiceschanged = () => speechSynthesis.getVoices();
        }

        let questionCount = 0;
        let currentQuestion = null;
        let currentAnswers = null;
        const answerLabels = ['A', 'B', 'C', 'D'];

        function rereadQuestion() {
            if (currentQuestion && currentAnswers) {
                readQuestionAndAnswers(currentQuestion.text, currentAnswers, answerLabels);
            }
        }

        function handleAnswer(btn, isCorrect, explanation) {
            const allBtns = document.querySelectorAll('.answer-btn');
            allBtns.forEach(b => b.disabled = true);

            const feedback = document.getElementById('feedback');
            const question = questions[questionCount % questions.length];
            const correctAnswer = question.answers[question.correct];

            speechSynthesis.cancel();

            if (isCorrect) {
                btn.classList.add('correct');
                lives++;
                score += 200;
                document.getElementById('lives').textContent = lives;
                document.getElementById('score').textContent = score;

                feedback.textContent = '\u2705 +1 Life! ' + explanation;
                feedback.className = 'feedback-text correct';

                speakFeedback("Correct!", 'en-GB', () => {
                    speakFeedback(explanation, 'en-GB', () => {
                        speakFeedback("Next question!", 'en-GB', () => {
                            questionCount++;
                            showQuestion();
                        }, true);
                    });
                });
            } else {
                btn.classList.add('wrong');

                feedback.textContent = '\u274C The answer is: ' + correctAnswer + '. ' + explanation;
                feedback.className = 'feedback-text wrong';

                speakFeedback("Wrong! The answer is: " + correctAnswer, 'en-GB', () => {
                    speakFeedback(explanation, 'en-GB', () => {
                        speakFeedback("Next question!", 'en-GB', () => {
                            questionCount++;
                            showQuestion();
                        }, true);
                    });
                });
            }
        }

        function speakFeedback(text, lang, callback, isLast = false) {
            isSpeakingFeedback = true;
            const voices = speechSynthesis.getVoices();
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = lang;
            utterance.rate = 1.0;

            const englishVoice = voices.find(v => v.lang === 'en-GB' && v.name.includes('Google')) ||
                                voices.find(v => v.lang.startsWith('en'));
            if (englishVoice) utterance.voice = englishVoice;

            utterance.onend = () => {
                if (isLast) isSpeakingFeedback = false;
                if (callback) callback();
            };
            speechSynthesis.speak(utterance);
        }

        function gameOver() {
            gameRunning = false;
            speechSynthesis.cancel();
            document.getElementById('question-overlay').style.display = 'none';
            document.getElementById('win-screen').style.display = 'none';
            document.getElementById('gameover-screen').style.display = 'flex';
            document.getElementById('final-level').textContent = level;
            document.getElementById('final-score').textContent = score;
        }

        function winGame() {
            gameRunning = false;
            speechSynthesis.cancel();
            document.getElementById('question-overlay').style.display = 'none';
            document.getElementById('gameover-screen').style.display = 'none';
            document.getElementById('win-screen').style.display = 'flex';
            document.getElementById('win-score').textContent = score;
            document.getElementById('win-compasses').textContent = compassCount;
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('gameover-screen').style.display = 'none';
            document.getElementById('win-screen').style.display = 'none';
            document.getElementById('question-overlay').style.display = 'block';

            level = 1;
            score = 0;
            lives = 3;
            distance = 0;
            checkpointDistance = 22000;
            gameSpeed = 4;
            baseSpeed = 4;
            isSpeakingFeedback = false;
            obstacles = [];
            compasses = [];
            powerUps = [];
            compassCount = 0;
            isInvincible = false;
            invincibleTimer = 0;
            comboCount = 0;
            comboTimer = 0;
            obstacleTimer = 0;
            compassSpawnTimer = 0;
            powerUpSpawnTimer = 0;
            questionCount = 0;

            document.getElementById('level').textContent = level;
            document.getElementById('score').textContent = score;
            document.getElementById('lives').textContent = lives;
            document.getElementById('compasses').textContent = compassCount;

            player.y = canvas.height - 150 - player.height;
            player.velocityY = 0;
            player.grounded = true;

            generateMountains();
            generateClouds();
            gameRunning = true;

            showQuestion();
        }

        // Gamepad support
        let gamepadConnected = false;
        let lastButtonStates = {};

        window.addEventListener('gamepadconnected', () => { gamepadConnected = true; });
        window.addEventListener('gamepaddisconnected', () => { gamepadConnected = false; });

        function pollGamepad() {
            const gamepads = navigator.getGamepads();
            if (!gamepads) return;

            for (const gamepad of gamepads) {
                if (!gamepad) continue;

                const buttons = gamepad.buttons;

                if ((buttons[7]?.pressed || buttons[6]?.pressed) && !lastButtonStates['jump']) {
                    jump();
                    lastButtonStates['jump'] = true;
                } else if (!buttons[7]?.pressed && !buttons[6]?.pressed) {
                    lastButtonStates['jump'] = false;
                }

                const answerMap = [
                    { btn: 2, answer: 0, key: 'X' },
                    { btn: 3, answer: 1, key: 'Y' },
                    { btn: 0, answer: 2, key: 'A' },
                    { btn: 1, answer: 3, key: 'B' }
                ];

                answerMap.forEach(({ btn, answer, key }) => {
                    if (buttons[btn]?.pressed && !lastButtonStates[key]) {
                        const answerBtns = document.querySelectorAll('.answer-btn');
                        if (answerBtns[answer] && !answerBtns[answer].disabled) {
                            answerBtns[answer].click();
                        }
                        lastButtonStates[key] = true;
                    } else if (!buttons[btn]?.pressed) {
                        lastButtonStates[key] = false;
                    }
                });
            }
            requestAnimationFrame(pollGamepad);
        }
        pollGamepad();

        // Event listeners
        window.addEventListener('resize', resizeCanvas);

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                jump();
            }

            const keyMap = { 'KeyA': 0, 'KeyB': 1, 'KeyC': 2, 'KeyD': 3 };
            if (keyMap.hasOwnProperty(e.code)) {
                const btns = document.querySelectorAll('.answer-btn');
                if (btns[keyMap[e.code]] && !btns[keyMap[e.code]].disabled) {
                    btns[keyMap[e.code]].click();
                }
            }
        });

        canvas.addEventListener('click', jump);
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); jump(); });
        document.getElementById('jump-btn').addEventListener('click', jump);
        document.getElementById('jump-btn').addEventListener('touchstart', (e) => { e.preventDefault(); jump(); });

        // Initialize
        resizeCanvas();
        generateMountains();
        generateClouds();
        gameLoop();
    </script>
</body>
</html>
