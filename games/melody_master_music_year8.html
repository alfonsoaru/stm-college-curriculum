<!DOCTYPE html>
<html lang="en" translate="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="google" content="notranslate">
    <title>Melody Master - Music Year 8 Autumn Term</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
            background: linear-gradient(135deg, #9C27B0 0%, #673AB7 100%);
            min-height: 100vh;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }

        #game-canvas {
            display: block;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            z-index: 100;
        }

        .hud-item {
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: 600;
            font-size: 1.1rem;
        }

        #question-overlay {
            display: block;
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 550px;
            z-index: 150;
            pointer-events: none;
        }

        .question-box {
            background: rgba(255,255,255,0.95);
            border-radius: 16px;
            padding: 1.2rem;
            text-align: center;
            animation: slideDown 0.3s ease;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            border: 3px solid #9C27B0;
            pointer-events: auto;
        }

        @keyframes slideDown {
            from { transform: translateY(-100px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .checkpoint-badge {
            background: linear-gradient(135deg, #9C27B0, #673AB7);
            color: white;
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 600;
            display: inline-block;
            margin-bottom: 0.5rem;
        }

        .question-text {
            font-size: 1.3rem;
            font-weight: 700;
            color: #1d1d1f;
            margin-bottom: 0.2rem;
        }

        .question-context {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 0.8rem;
        }

        .answers-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .answer-btn {
            background: #f5f5f7;
            border: 2px solid #e5e5e5;
            padding: 0.6rem 0.8rem;
            border-radius: 10px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .answer-btn:hover {
            background: #e8e8ed;
            border-color: #9C27B0;
            transform: translateY(-2px);
        }

        .answer-btn.correct {
            background: #22c55e;
            border-color: #16a34a;
            color: white;
        }

        .answer-btn.wrong {
            background: #ef4444;
            border-color: #dc2626;
            color: white;
        }

        #start-screen, #gameover-screen, #win-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #9C27B0 0%, #673AB7 100%);
            z-index: 300;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            padding: 2rem;
        }

        #gameover-screen, #win-screen {
            display: none;
        }

        .title {
            font-size: 3.5rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            text-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.3rem;
            opacity: 0.9;
            margin-bottom: 2rem;
        }

        .instructions {
            background: rgba(255,255,255,0.1);
            padding: 2rem;
            border-radius: 15px;
            margin-bottom: 2rem;
            max-width: 600px;
            text-align: left;
        }

        .instructions em {
            opacity: 0.8;
            font-size: 0.9em;
        }

        .instructions h3 {
            margin-bottom: 1rem;
            font-size: 1.3rem;
        }

        .instructions p {
            margin: 0.5rem 0;
            font-size: 1rem;
        }

        .start-btn {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            border: none;
            padding: 1.2rem 3rem;
            font-size: 1.4rem;
            font-weight: 700;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(245, 158, 11, 0.4);
        }

        .start-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 30px rgba(245, 158, 11, 0.5);
        }

        .theme-emoji {
            font-size: 5rem;
            margin-bottom: 1rem;
        }

        .result-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
        }

        .stats {
            background: rgba(255,255,255,0.1);
            padding: 1.5rem 2rem;
            border-radius: 12px;
            margin: 1.5rem 0;
        }

        .feedback-text {
            font-size: 0.9rem;
            margin-top: 0.5rem;
            padding: 0.5rem;
            border-radius: 6px;
            display: none;
            font-weight: 600;
        }

        .feedback-text.correct {
            background: rgba(34, 197, 94, 0.2);
            color: #166534;
            display: block;
        }

        .feedback-text.wrong {
            background: rgba(239, 68, 68, 0.2);
            color: #991b1b;
            display: block;
            font-size: 0.8rem;
        }

        #mobile-controls {
            display: none;
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }

        .jump-btn {
            background: rgba(255,255,255,0.9);
            border: none;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            font-size: 2.5rem;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        @media (max-width: 768px) {
            #mobile-controls {
                display: block;
            }
            .title {
                font-size: 2.5rem;
            }
            .question-text {
                font-size: 1.1rem;
            }
            .answers-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>

        <div id="hud">
            <div class="hud-item">üéµ Level: <span id="level">1</span>/3</div>
            <div class="hud-item">üéº <span id="notes">0</span></div>
            <div class="hud-item">‚≠ê <span id="score">0</span></div>
            <div class="hud-item">‚ù§Ô∏è <span id="lives">3</span></div>
        </div>

        <div id="mobile-controls">
            <button class="jump-btn" id="jump-btn">‚¨ÜÔ∏è</button>
        </div>

        <div id="question-overlay">
            <div class="question-box">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                    <div class="checkpoint-badge">üéµ Q<span id="checkpoint-num">1</span>/<span id="total-questions">12</span></div>
                    <button id="read-again-btn" onclick="rereadQuestion()" style="background: #9C27B0; color: white; border: none; padding: 5px 12px; border-radius: 15px; font-size: 0.8rem; cursor: pointer; font-weight: 600;">üîä Read Again</button>
                </div>
                <div class="question-text" id="q-text">Loading...</div>
                <div class="question-context" id="q-context">Music Theory</div>
                <div class="answers-grid" id="answers"></div>
                <div class="feedback-text" id="feedback"></div>
            </div>
        </div>

        <div id="start-screen">
            <div class="theme-emoji">üéº</div>
            <h1 class="title">Melody Master</h1>
            <p class="subtitle">Run, Jump & Master Year 8 Music!<br><em style="font-size: 0.9em; opacity: 0.8;">Film Music, Baroque Composition & Music Theory</em></p>

            <div class="instructions">
                <h3>How to Play</h3>
                <p>üéª <strong>RUN</strong> through the concert hall!</p>
                <p>üé¨ Master <strong>FILM MUSIC</strong> and <strong>BAROQUE</strong> concepts!</p>
                <p>üéµ Collect musical notes for bonus points!</p>

                <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.2);">
                    <p><strong>‚å®Ô∏è Keyboard:</strong> SPACE = Jump | A B C D = Answer</p>
                    <p><strong>üéÆ Xbox:</strong> RT/LT = Jump | X Y A B = Answer</p>
                </div>

                <p style="margin-top: 1rem;">‚úÖ Correct = +1 Life | Learn leitmotifs, fugues & more!</p>
            </div>

            <button class="start-btn" onclick="startGame()">Start Performance! üé≠</button>
        </div>

        <div id="gameover-screen">
            <div class="result-icon">üíî</div>
            <h1 class="title">Game Over!</h1>
            <p class="subtitle">The orchestra needs more practice!</p>
            <div class="stats">
                <p>Level: <span id="final-level">1</span></p>
                <p>Score: <span id="final-score">0</span></p>
            </div>
            <button class="start-btn" onclick="startGame()">Try Again! üîÑ</button>
        </div>

        <div id="win-screen">
            <div class="result-icon">üèÜ</div>
            <h1 class="title">Bravo!</h1>
            <p class="subtitle">You're a true Melody Master!</p>
            <div class="stats">
                <p>üéº Notes: <span id="win-notes">0</span></p>
                <p>‚≠ê Score: <span id="win-score">0</span></p>
            </div>
            <button class="start-btn" onclick="startGame()">Play Again! üîÑ</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameRunning = false;
        let level = 1;
        let score = 0;
        let lives = 3;
        let distance = 0;
        let checkpointDistance = 22000;
        let gameSpeed = 4;
        let baseSpeed = 4;
        let isSpeakingFeedback = false;

        // Collectibles
        let notes = [];
        let noteCount = 0;

        // Power-ups
        let powerUps = [];
        let isInvincible = false;
        let invincibleTimer = 0;

        // Player
        let player = {
            x: 100,
            y: 0,
            width: 50,
            height: 70,
            velocityY: 0,
            jumping: false,
            grounded: true
        };

        // Physics
        const gravity = 0.8;
        const jumpForce = -16;

        // Obstacles
        let obstacles = [];
        let obstacleTimer = 0;

        // Background
        let bgOffset = 0;
        let curtains = [];
        let chandeliers = [];

        // Music Year 8 Autumn Term Questions - Film Music & Baroque
        const questions = [
            // Film Music - Leitmotifs
            {
                text: "What is a leitmotif in film music?",
                context: "Film Music Composition",
                answers: ["A recurring theme for a character/idea", "A type of microphone", "Background noise", "The film's credits music"],
                correct: 0,
                english: "A leitmotif is a recurring musical theme associated with a particular character, place, or idea in a film. Think of Darth Vader's Imperial March or the Jaws theme - you instantly recognise who or what is being represented!"
            },
            {
                text: "What is the difference between diegetic and non-diegetic music?",
                context: "Film Music Terminology",
                answers: ["Diegetic = heard by characters, Non-diegetic = only audience hears", "They are the same thing", "Diegetic = loud, Non-diegetic = quiet", "Diegetic = vocals, Non-diegetic = instruments"],
                correct: 0,
                english: "Diegetic music exists within the film world - characters can hear it (like a radio playing). Non-diegetic music is the soundtrack only the audience hears, used to enhance mood and emotion without being part of the scene."
            },
            {
                text: "Which composer is famous for Star Wars and Indiana Jones scores?",
                context: "Famous Film Composers",
                answers: ["John Williams", "Hans Zimmer", "J.S. Bach", "Mozart"],
                correct: 0,
                english: "John Williams is one of the most celebrated film composers ever. He created iconic scores for Star Wars, Indiana Jones, Harry Potter, Jurassic Park, and many more. His leitmotifs are instantly recognisable worldwide!"
            },
            {
                text: "What does 'orchestration' mean in film music?",
                context: "Film Scoring Techniques",
                answers: ["Choosing which instruments play which parts", "Recording dialogue", "Editing the film", "Writing the script"],
                correct: 0,
                english: "Orchestration is the art of deciding which instruments will play each part of a composition. Film composers carefully choose instruments to create specific emotions - strings for romance, brass for heroism, low notes for tension."
            },
            {
                text: "What is a crescendo?",
                context: "Musical Dynamics",
                answers: ["Gradually getting louder", "Gradually getting quieter", "Staying the same volume", "Playing very fast"],
                correct: 0,
                english: "A crescendo is when music gradually increases in volume, often used to build tension or excitement. The opposite is diminuendo (getting quieter). Film composers use these dynamics to guide the audience's emotions."
            },
            {
                text: "What creates dramatic tension in film music?",
                context: "Film Music Techniques",
                answers: ["Low notes, minor keys, dissonance", "Happy melodies only", "No music at all", "Fast tempos only"],
                correct: 0,
                english: "Tension is created using low-pitched instruments, minor keys, dissonant harmonies, and silence. Composers also use ostinatos (repeating patterns) and sustained notes to keep audiences on edge during scary or suspenseful scenes."
            },
            // Baroque Music - Bach & Handel
            {
                text: "The Baroque period lasted from approximately...",
                context: "Baroque Music History",
                answers: ["1600-1750", "1900-2000", "1400-1500", "1800-1900"],
                correct: 0,
                english: "The Baroque era (1600-1750) featured ornate, decorative music with complex harmonies. This period saw the development of opera, concertos, and famous composers like Bach and Handel. The style is known for its grandeur and emotional expression."
            },
            {
                text: "What is a fugue?",
                context: "Baroque Composition",
                answers: ["A piece where a theme is imitated in different voices", "A type of dance", "A quiet solo piece", "A love song"],
                correct: 0,
                english: "A fugue starts with a main theme (subject) in one voice, then other voices enter with the same theme at different pitches. The voices weave together using counterpoint, creating complex interlocking melodies. Bach was the master of fugues!"
            },
            {
                text: "What is basso continuo?",
                context: "Baroque Music Features",
                answers: ["A continuous bass line providing harmonic foundation", "A type of violin", "A fast tempo marking", "A Baroque dance"],
                correct: 0,
                english: "Basso continuo is a continuous bass line played by low instruments (cello, bassoon) with harmonic accompaniment (harpsichord, organ). It provides the harmonic foundation for all Baroque ensemble music - nearly universal in this period."
            },
            {
                text: "Which instruments were typical of Baroque music?",
                context: "Baroque Instruments",
                answers: ["Harpsichord and organ", "Electric guitar", "Synthesizer", "Drum kit"],
                correct: 0,
                english: "The harpsichord and organ were the main keyboard instruments of the Baroque era. Unlike pianos, harpsichords pluck strings rather than strike them, creating their distinctive bright, clear sound perfect for counterpoint."
            },
            {
                text: "What are 'terraced dynamics'?",
                context: "Baroque Performance Style",
                answers: ["Sudden changes between loud and soft", "Gradual volume changes", "Always playing quietly", "Using electronic effects"],
                correct: 0,
                english: "Terraced dynamics are sudden shifts between loud and soft, rather than gradual changes. This happened because harpsichords and organs couldn't make gradual volume changes - they created contrast through abrupt dynamic shifts, which became a defining Baroque characteristic."
            },
            {
                text: "Who composed The Messiah, including the famous 'Hallelujah Chorus'?",
                context: "Famous Baroque Composers",
                answers: ["George Frideric Handel", "Johann Sebastian Bach", "Antonio Vivaldi", "John Williams"],
                correct: 0,
                english: "Handel composed 'Messiah' in just 24 days in 1741! The 'Hallelujah Chorus' is so famous that audiences traditionally stand during its performance. Handel was known for his operas and oratorios, while Bach focused more on church music and fugues."
            }
        ];

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            player.y = canvas.height - 150 - player.height;
            ctx.imageSmoothingEnabled = false;
        }

        function generateCurtains() {
            curtains = [];
            for (let i = 0; i < 6; i++) {
                curtains.push({
                    x: i * 350 + Math.random() * 100,
                    height: 180 + Math.random() * 60
                });
            }
        }

        function generateChandeliers() {
            chandeliers = [];
            for (let i = 0; i < 5; i++) {
                chandeliers.push({
                    x: i * 400 + Math.random() * 150,
                    y: 60 + Math.random() * 30,
                    size: 40 + Math.random() * 20
                });
            }
        }

        function drawBackground() {
            // Concert hall ceiling gradient
            const ceilingGradient = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.4);
            ceilingGradient.addColorStop(0, '#1a0a1f');
            ceilingGradient.addColorStop(1, '#3d1f47');
            ctx.fillStyle = ceilingGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height * 0.4);

            // Ornate ceiling pattern
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
            ctx.lineWidth = 1;
            for (let x = -bgOffset % 100; x < canvas.width; x += 100) {
                ctx.beginPath();
                ctx.arc(x, 80, 30, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Chandeliers
            chandeliers.forEach(ch => {
                const chandX = ((ch.x - bgOffset * 0.3) % (canvas.width + 500)) - 100;
                drawChandelier(chandX, ch.y, ch.size);
            });

            // Wall with velvet curtains
            const wallGradient = ctx.createLinearGradient(0, canvas.height * 0.3, 0, canvas.height * 0.7);
            wallGradient.addColorStop(0, '#4a1c5c');
            wallGradient.addColorStop(1, '#2d0a38');
            ctx.fillStyle = wallGradient;
            ctx.fillRect(0, canvas.height * 0.3, canvas.width, canvas.height * 0.4);

            // Curtains
            curtains.forEach(curtain => {
                const curtainX = ((curtain.x - bgOffset * 0.5) % (canvas.width + 600)) - 200;
                drawCurtain(curtainX, canvas.height * 0.25, curtain.height);
            });

            // Stage floor - polished wood
            const floorGradient = ctx.createLinearGradient(0, canvas.height - 150, 0, canvas.height);
            floorGradient.addColorStop(0, '#8B4513');
            floorGradient.addColorStop(0.5, '#A0522D');
            floorGradient.addColorStop(1, '#654321');
            ctx.fillStyle = floorGradient;
            ctx.fillRect(0, canvas.height - 150, canvas.width, 150);

            // Stage floor shine
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            for (let x = -bgOffset % 80; x < canvas.width; x += 80) {
                ctx.fillRect(x, canvas.height - 145, 40, 140);
            }

            // Stage edge
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(0, canvas.height - 155, canvas.width, 8);
        }

        function drawChandelier(x, y, size) {
            // Chain
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, y);
            ctx.stroke();

            // Main body
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.ellipse(x, y + 10, size * 0.4, size * 0.2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Crystals/lights
            ctx.fillStyle = '#FFFACD';
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const crystalX = x + Math.cos(angle) * size * 0.3;
                const crystalY = y + 20 + Math.sin(angle) * 10;
                ctx.beginPath();
                ctx.arc(crystalX, crystalY, 5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Glow effect
            const glow = ctx.createRadialGradient(x, y + 15, 0, x, y + 15, size);
            glow.addColorStop(0, 'rgba(255, 250, 205, 0.3)');
            glow.addColorStop(1, 'rgba(255, 250, 205, 0)');
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(x, y + 15, size, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawCurtain(x, y, height) {
            // Velvet curtain
            const curtainGradient = ctx.createLinearGradient(x, y, x + 80, y);
            curtainGradient.addColorStop(0, '#8B0000');
            curtainGradient.addColorStop(0.3, '#DC143C');
            curtainGradient.addColorStop(0.7, '#8B0000');
            curtainGradient.addColorStop(1, '#4a0000');
            ctx.fillStyle = curtainGradient;

            // Draped effect
            ctx.beginPath();
            ctx.moveTo(x, y);
            for (let i = 0; i <= 4; i++) {
                const curveX = x + (i * 20);
                const curveY = y + height + Math.sin(i * 0.8) * 20;
                ctx.lineTo(curveX, curveY);
            }
            ctx.lineTo(x + 80, y);
            ctx.closePath();
            ctx.fill();

            // Gold trim
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + 80, y);
            ctx.stroke();

            // Tassel
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x + 40, y + height + 30, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillRect(x + 38, y + height + 30, 4, 20);
        }

        function drawPlayer() {
            // Body - conductor's outfit
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(player.x, player.y + 20, player.width - 10, 35);

            // White shirt front
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(player.x + 12, player.y + 22, 16, 30);

            // Head
            ctx.fillStyle = '#fcd5b8';
            ctx.beginPath();
            ctx.arc(player.x + 20, player.y + 12, 15, 0, Math.PI * 2);
            ctx.fill();

            // Conductor's hair
            ctx.fillStyle = '#2c2c2c';
            ctx.beginPath();
            ctx.arc(player.x + 20, player.y + 6, 12, Math.PI, 0);
            ctx.fill();

            // Bow tie
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.moveTo(player.x + 15, player.y + 25);
            ctx.lineTo(player.x + 25, player.y + 25);
            ctx.lineTo(player.x + 20, player.y + 28);
            ctx.closePath();
            ctx.fill();

            // Conductor's baton
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 3;
            ctx.beginPath();
            if (player.grounded) {
                ctx.moveTo(player.x + 35, player.y + 25);
                ctx.lineTo(player.x + 55, player.y + 15);
            } else {
                ctx.moveTo(player.x + 35, player.y + 30);
                ctx.lineTo(player.x + 50, player.y + 10);
            }
            ctx.stroke();

            // Legs
            ctx.fillStyle = '#1a1a1a';
            if (player.grounded) {
                ctx.fillRect(player.x + 5, player.y + 55, 12, 15);
                ctx.fillRect(player.x + 22, player.y + 55, 12, 15);
            } else {
                ctx.fillRect(player.x + 5, player.y + 50, 12, 20);
                ctx.fillRect(player.x + 22, player.y + 50, 12, 20);
            }
        }

        function spawnObstacle() {
            const types = [
                { width: 50, height: 55, emoji: 'üéª' },
                { width: 55, height: 45, emoji: 'üé∫' },
                { width: 45, height: 50, emoji: 'ü™ò' },
                { width: 50, height: 50, emoji: 'üé∑' },
                { width: 60, height: 40, emoji: 'üé∏' },
                { width: 45, height: 55, emoji: 'üéπ' },
                { width: 50, height: 45, emoji: 'üìØ' }
            ];
            const type = types[Math.floor(Math.random() * types.length)];

            obstacles.push({
                x: canvas.width + 50,
                y: canvas.height - 150 - type.height,
                width: type.width,
                height: type.height,
                emoji: type.emoji
            });

            if (Math.random() < 0.15 && level > 1) {
                const type2 = types[Math.floor(Math.random() * types.length)];
                obstacles.push({
                    x: canvas.width + 150,
                    y: canvas.height - 150 - type2.height,
                    width: type2.width,
                    height: type2.height,
                    emoji: type2.emoji
                });
            }
        }

        function spawnNote() {
            const heights = [80, 120, 160];
            const noteEmojis = ['üéµ', 'üé∂', 'üéº'];
            notes.push({
                x: canvas.width + 50,
                y: canvas.height - 150 - heights[Math.floor(Math.random() * heights.length)],
                emoji: noteEmojis[Math.floor(Math.random() * noteEmojis.length)],
                collected: false
            });
        }

        function spawnPowerUp() {
            const types = ['shield', 'magnet', 'slow'];
            powerUps.push({
                x: canvas.width + 50,
                y: canvas.height - 280,
                type: types[Math.floor(Math.random() * types.length)],
                collected: false
            });
        }

        function drawObstacles() {
            obstacles.forEach(obs => {
                ctx.font = `${obs.height}px Arial`;
                ctx.fillText(obs.emoji, obs.x, obs.y + obs.height - 5);
            });
        }

        function drawNotes() {
            notes.forEach(n => {
                if (!n.collected) {
                    ctx.font = '35px Arial';
                    const bob = Math.sin(Date.now() / 200 + n.x) * 5;
                    ctx.fillText(n.emoji, n.x, n.y + bob);
                }
            });
        }

        function drawPowerUps() {
            powerUps.forEach(p => {
                if (!p.collected) {
                    ctx.font = '40px Arial';
                    const bob = Math.sin(Date.now() / 150) * 8;
                    let emoji = p.type === 'shield' ? '‚≠ê' : p.type === 'magnet' ? 'üß≤' : '‚è±Ô∏è';
                    ctx.fillText(emoji, p.x, p.y + bob);
                }
            });
        }

        function drawProgressBar() {
            const barWidth = 200;
            const barHeight = 10;
            const barX = canvas.width / 2 - barWidth / 2;
            const barY = 70;
            const progress = Math.min(distance / checkpointDistance, 1);

            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            ctx.fillStyle = '#22c55e';
            ctx.fillRect(barX, barY, barWidth * progress, barHeight);

            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.fillText('üèÅ', barX + barWidth - 15, barY + 10);
        }

        let noteSpawnTimer = 0;
        let powerUpSpawnTimer = 0;
        let comboCount = 0;
        let comboTimer = 0;

        function update() {
            if (!gameRunning) return;

            gameSpeed = Math.min(baseSpeed + 5, baseSpeed + (distance / 5000));

            bgOffset += gameSpeed;
            distance += gameSpeed;

            if (!player.grounded) {
                player.velocityY += gravity;
                player.y += player.velocityY;

                if (player.y >= canvas.height - 150 - player.height) {
                    player.y = canvas.height - 150 - player.height;
                    player.velocityY = 0;
                    player.grounded = true;
                    player.jumping = false;
                }
            }

            obstacleTimer++;
            const obstacleFreq = Math.max(80, 180 - gameSpeed * 15);
            if (obstacleTimer > obstacleFreq + Math.random() * 60) {
                spawnObstacle();
                obstacleTimer = 0;
            }

            noteSpawnTimer++;
            if (noteSpawnTimer > 40 + Math.random() * 30) {
                spawnNote();
                noteSpawnTimer = 0;
            }

            powerUpSpawnTimer++;
            if (powerUpSpawnTimer > 400 + Math.random() * 200) {
                spawnPowerUp();
                powerUpSpawnTimer = 0;
            }

            obstacles.forEach(obs => { obs.x -= gameSpeed; });
            notes.forEach(n => { n.x -= gameSpeed; });
            powerUps.forEach(p => { p.x -= gameSpeed; });

            obstacles = obstacles.filter(obs => obs.x > -100);
            notes = notes.filter(n => n.x > -100);
            powerUps = powerUps.filter(p => p.x > -100);

            if (!isInvincible) {
                obstacles.forEach(obs => {
                    if (player.x < obs.x + obs.width - 10 &&
                        player.x + player.width - 10 > obs.x &&
                        player.y + player.height > obs.y &&
                        player.y < obs.y + obs.height) {
                        hitObstacle();
                    }
                });
            }

            notes.forEach(n => {
                if (!n.collected &&
                    player.x < n.x + 35 &&
                    player.x + player.width > n.x &&
                    player.y < n.y + 35 &&
                    player.y + player.height > n.y - 20) {
                    n.collected = true;
                    noteCount++;
                    score += 50;
                    comboCount++;
                    comboTimer = 60;
                    if (comboCount >= 3) score += comboCount * 20;
                }
            });

            powerUps.forEach(p => {
                if (!p.collected &&
                    player.x < p.x + 40 &&
                    player.x + player.width > p.x &&
                    player.y < p.y + 20 &&
                    player.y + player.height > p.y - 30) {
                    p.collected = true;
                    activatePowerUp(p.type);
                }
            });

            if (comboTimer > 0) comboTimer--;
            else comboCount = 0;

            if (isInvincible) {
                invincibleTimer--;
                if (invincibleTimer <= 0) isInvincible = false;
            }

            if (distance >= checkpointDistance) reachCheckpoint();

            document.getElementById('score').textContent = score;
            document.getElementById('notes').textContent = noteCount;
        }

        function activatePowerUp(type) {
            if (type === 'shield') {
                isInvincible = true;
                invincibleTimer = 180;
            } else if (type === 'slow') {
                gameSpeed = Math.max(3, gameSpeed - 2);
                setTimeout(() => { gameSpeed = baseSpeed; }, 3000);
            } else if (type === 'magnet') {
                notes.forEach(n => {
                    if (!n.collected && n.x < player.x + 300) {
                        n.x = player.x + 30;
                        n.y = player.y + 20;
                    }
                });
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            drawNotes();
            drawPowerUps();
            drawObstacles();
            drawPlayer();
            drawProgressBar();

            if (comboCount >= 3) {
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 24px Arial';
                ctx.fillText(`COMBO x${comboCount}!`, player.x - 20, player.y - 30);
            }

            if (isInvincible) {
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(player.x + 25, player.y + 35, 45, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function jump() {
            if (player.grounded && gameRunning) {
                player.velocityY = jumpForce;
                player.grounded = false;
                player.jumping = true;
            }
        }

        function hitObstacle() {
            lives--;
            document.getElementById('lives').textContent = lives;

            if (lives <= 0) {
                gameOver();
            } else {
                obstacles = [];
                distance = Math.max(0, distance - 200);
                canvas.style.filter = 'brightness(2)';
                setTimeout(() => canvas.style.filter = 'none', 100);
            }
        }

        function reachCheckpoint() {
            distance = 0;
            level++;

            if (level > 3) {
                winGame();
                return;
            }

            checkpointDistance = 22000 + level * 2000;
            baseSpeed = 4 + level * 0.5;
            gameSpeed = baseSpeed;
            document.getElementById('level').textContent = level;
        }

        // TTS Functions
        function speak(text, lang = 'en-GB') {
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = lang;
                utterance.rate = 0.9;
                const voices = speechSynthesis.getVoices();
                const voice = voices.find(v => v.lang.startsWith(lang.split('-')[0]));
                if (voice) utterance.voice = voice;
                speechSynthesis.speak(utterance);
            }
        }

        function showQuestion() {
            const question = questions[questionCount % questions.length];
            currentQuestion = question;

            const questionInCycle = (questionCount % questions.length) + 1;
            document.getElementById('checkpoint-num').textContent = questionInCycle;
            document.getElementById('total-questions').textContent = questions.length;
            document.getElementById('q-text').textContent = question.text;
            document.getElementById('q-context').textContent = question.context;

            const answersDiv = document.getElementById('answers');
            answersDiv.innerHTML = '';

            const shuffledAnswers = question.answers.map((ans, i) => ({ text: ans, isCorrect: i === question.correct }));
            shuffledAnswers.sort(() => Math.random() - 0.5);
            currentAnswers = shuffledAnswers;

            const labels = ['A', 'B', 'C', 'D'];
            shuffledAnswers.forEach((ans, i) => {
                const btn = document.createElement('button');
                btn.className = 'answer-btn';
                btn.onclick = () => handleAnswer(btn, ans.isCorrect, question.english);
                btn.innerHTML = `<strong>${labels[i]}</strong> ${ans.text}`;
                answersDiv.appendChild(btn);
            });

            document.getElementById('feedback').textContent = '';
            document.getElementById('feedback').className = 'feedback-text';

            readQuestionAndAnswers(question.text, shuffledAnswers, labels);
        }

        function readQuestionAndAnswers(questionText, answers, labels) {
            if (!('speechSynthesis' in window)) return;
            if (isSpeakingFeedback) return;

            speechSynthesis.cancel();

            const voices = speechSynthesis.getVoices();
            const englishVoice = voices.find(v => v.lang === 'en-GB' && v.name.includes('Google')) ||
                                voices.find(v => v.lang.startsWith('en'));

            const queue = [];

            // Question in English
            const qUtterance = new SpeechSynthesisUtterance(questionText);
            qUtterance.lang = 'en-GB';
            qUtterance.rate = 0.9;
            if (englishVoice) qUtterance.voice = englishVoice;
            queue.push(qUtterance);

            // Answers
            answers.forEach((ans, i) => {
                const labelUtterance = new SpeechSynthesisUtterance(labels[i]);
                labelUtterance.lang = 'en-GB';
                labelUtterance.rate = 1.0;
                if (englishVoice) labelUtterance.voice = englishVoice;
                queue.push(labelUtterance);

                const ansUtterance = new SpeechSynthesisUtterance(ans.text);
                ansUtterance.lang = 'en-GB';
                ansUtterance.rate = 0.85;
                if (englishVoice) ansUtterance.voice = englishVoice;
                queue.push(ansUtterance);
            });

            let i = 0;
            function playNext() {
                if (i < queue.length) {
                    queue[i].onend = playNext;
                    speechSynthesis.speak(queue[i]);
                    i++;
                }
            }
            playNext();
        }

        if ('speechSynthesis' in window) {
            speechSynthesis.getVoices();
            speechSynthesis.onvoiceschanged = () => speechSynthesis.getVoices();
        }

        let questionCount = 0;
        let currentQuestion = null;
        let currentAnswers = null;
        const answerLabels = ['A', 'B', 'C', 'D'];

        function rereadQuestion() {
            if (currentQuestion && currentAnswers) {
                readQuestionAndAnswers(currentQuestion.text, currentAnswers, answerLabels);
            }
        }

        function handleAnswer(btn, isCorrect, explanation) {
            const allBtns = document.querySelectorAll('.answer-btn');
            allBtns.forEach(b => b.disabled = true);

            const feedback = document.getElementById('feedback');
            const question = questions[questionCount % questions.length];
            const correctAnswer = question.answers[question.correct];

            speechSynthesis.cancel();

            if (isCorrect) {
                btn.classList.add('correct');
                lives++;
                score += 200;
                document.getElementById('lives').textContent = lives;
                document.getElementById('score').textContent = score;

                feedback.textContent = '‚úÖ +1 ‚ù§Ô∏è Excellent!';
                feedback.className = 'feedback-text correct';

                speakFeedback("Correct!", 'en-GB', () => {
                    speakFeedback("Next question!", 'en-GB', () => {
                        questionCount++;
                        showQuestion();
                    }, true);
                });
            } else {
                btn.classList.add('wrong');

                feedback.textContent = '‚ùå ' + correctAnswer;
                feedback.className = 'feedback-text wrong';

                speakFeedback("Wrong! The answer is:", 'en-GB', () => {
                    speakFeedback(correctAnswer, 'en-GB', () => {
                        if (explanation) {
                            speakFeedback(explanation, 'en-GB', () => {
                                speakFeedback("Next question!", 'en-GB', () => {
                                    questionCount++;
                                    showQuestion();
                                }, true);
                            });
                        } else {
                            speakFeedback("Next question!", 'en-GB', () => {
                                questionCount++;
                                showQuestion();
                            }, true);
                        }
                    });
                });
            }
        }

        function speakFeedback(text, lang, callback, isLast = false) {
            isSpeakingFeedback = true;
            const voices = speechSynthesis.getVoices();
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = lang;
            utterance.rate = 1.0;

            const englishVoice = voices.find(v => v.lang === 'en-GB' && v.name.includes('Google')) ||
                                voices.find(v => v.lang.startsWith('en'));
            if (englishVoice) utterance.voice = englishVoice;

            utterance.onend = () => {
                if (isLast) isSpeakingFeedback = false;
                if (callback) callback();
            };
            speechSynthesis.speak(utterance);
        }

        function gameOver() {
            gameRunning = false;
            speechSynthesis.cancel();
            document.getElementById('question-overlay').style.display = 'none';
            document.getElementById('win-screen').style.display = 'none';
            document.getElementById('gameover-screen').style.display = 'flex';
            document.getElementById('final-level').textContent = level;
            document.getElementById('final-score').textContent = score;
        }

        function winGame() {
            gameRunning = false;
            speechSynthesis.cancel();
            document.getElementById('question-overlay').style.display = 'none';
            document.getElementById('gameover-screen').style.display = 'none';
            document.getElementById('win-screen').style.display = 'flex';
            document.getElementById('win-score').textContent = score;
            document.getElementById('win-notes').textContent = noteCount;
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('gameover-screen').style.display = 'none';
            document.getElementById('win-screen').style.display = 'none';
            document.getElementById('question-overlay').style.display = 'block';

            level = 1;
            score = 0;
            lives = 3;
            distance = 0;
            checkpointDistance = 22000;
            gameSpeed = 4;
            baseSpeed = 4;
            isSpeakingFeedback = false;
            obstacles = [];
            notes = [];
            powerUps = [];
            noteCount = 0;
            isInvincible = false;
            invincibleTimer = 0;
            comboCount = 0;
            comboTimer = 0;
            obstacleTimer = 0;
            noteSpawnTimer = 0;
            powerUpSpawnTimer = 0;
            questionCount = 0;

            document.getElementById('level').textContent = level;
            document.getElementById('score').textContent = score;
            document.getElementById('lives').textContent = lives;
            document.getElementById('notes').textContent = noteCount;

            player.y = canvas.height - 150 - player.height;
            player.velocityY = 0;
            player.grounded = true;

            generateCurtains();
            generateChandeliers();
            gameRunning = true;

            showQuestion();
        }

        // Gamepad support
        let gamepadConnected = false;
        let lastButtonStates = {};

        window.addEventListener('gamepadconnected', () => { gamepadConnected = true; });
        window.addEventListener('gamepaddisconnected', () => { gamepadConnected = false; });

        function pollGamepad() {
            const gamepads = navigator.getGamepads();
            if (!gamepads) return;

            for (const gamepad of gamepads) {
                if (!gamepad) continue;

                const buttons = gamepad.buttons;

                if ((buttons[7]?.pressed || buttons[6]?.pressed) && !lastButtonStates['jump']) {
                    jump();
                    lastButtonStates['jump'] = true;
                } else if (!buttons[7]?.pressed && !buttons[6]?.pressed) {
                    lastButtonStates['jump'] = false;
                }

                const answerMap = [
                    { btn: 2, answer: 0, key: 'X' },
                    { btn: 3, answer: 1, key: 'Y' },
                    { btn: 0, answer: 2, key: 'A' },
                    { btn: 1, answer: 3, key: 'B' }
                ];

                answerMap.forEach(({ btn, answer, key }) => {
                    if (buttons[btn]?.pressed && !lastButtonStates[key]) {
                        const answerBtns = document.querySelectorAll('.answer-btn');
                        if (answerBtns[answer] && !answerBtns[answer].disabled) {
                            answerBtns[answer].click();
                        }
                        lastButtonStates[key] = true;
                    } else if (!buttons[btn]?.pressed) {
                        lastButtonStates[key] = false;
                    }
                });
            }
            requestAnimationFrame(pollGamepad);
        }
        pollGamepad();

        // Event listeners
        window.addEventListener('resize', resizeCanvas);

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                jump();
            }

            const keyMap = { 'KeyA': 0, 'KeyB': 1, 'KeyC': 2, 'KeyD': 3 };
            if (keyMap.hasOwnProperty(e.code)) {
                const btns = document.querySelectorAll('.answer-btn');
                if (btns[keyMap[e.code]] && !btns[keyMap[e.code]].disabled) {
                    btns[keyMap[e.code]].click();
                }
            }
        });

        canvas.addEventListener('click', jump);
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); jump(); });
        document.getElementById('jump-btn').addEventListener('click', jump);
        document.getElementById('jump-btn').addEventListener('touchstart', (e) => { e.preventDefault(); jump(); });

        // Initialize
        resizeCanvas();
        generateCurtains();
        generateChandeliers();
        gameLoop();
    </script>
</body>
</html>
